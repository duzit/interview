## 面试相关 

### 列举几种类型的DOM节点
* 元素节点 span ul li
* 文本节点 <span>欢迎你</span>
* 属性节点 title 

### JavaScript有哪些垃圾回收机制
* 标记清除
  > 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量，
    以及被环境中变量所引用的变量的标记，在完成这些之后仍然存在的标记就是要删除的变量。
* 引用计数
  > 策略是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，
    这个值的引用次数就+1，如果该变量的值变成了另一个，这个值的引用次数就-1。当这个值的引用
    次数为0时，就说明没有变量在使用这个值，可以将它占用的空间回收，垃圾回收器会在运行时清理
    引用次数为0的值占用的空间。

### JavaScript标签中defer和async属性的区别
* defer 属性规定是否延迟执行脚本，直到页面加载为止。async 属性规定脚本一旦可用，就异步执行。
* defer 并行加载JavaScript 文件， 会按照页面上script 标签的顺序执行。async 并行加载JavaScript 文件，
  下载完成立即执行，不会按照页面上JavaScript 标签的顺序执行。

### 闭包的理解
* 优缺点
  > 优点：可以避免全局变量的污染
  > 缺点：常驻内存，增加内存使用量，使用不当容易造成内存泄露。
* 特性
  > 函数嵌套函数
  > 在函数内部可以引用外部的参数和变量
  > 参数和变量不会以垃圾回收机制回收

### 如何实现浏览器内多个标签页之前的通信
* localStorage()
* cookie

### null和undefined的区别是什么
* 当声明的变量还未初始化时，变量的默认值为undefined ,
  null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
* undefined 表示“缺少值”， 即此处应该有一个值，但是还没有定义，典型用法是如下。
    如果变量声明了，但没有赋值，它就等于undefined 。
    当调用函数时，如果没有提供应该提供的参数，该参数就等于undefined 。
    如果对象没有赋值，该属性的值为undefined 。
    当函数没有返回值时， 默认返回undefined 。
  null 表示“ 没有对象” ， 即此处不应该有值，典型用法是如下。
    作为函数的参数， 表示该函数的参数不是对象。
    作为对象原型链的终点。

### Vue中key的作用
* 准确：如果不加key，那么Vue会选择复用节点(就地更新策略)，导致之前节点的状态保留下来，会产生一系列bug。
* 快速：key的唯一性可以被Map数据结构充分利用。

### css选择器 特性 优先级
#### 特性
* 继承-子类继承父类
* 优先级-不同类别样式的权重
* 层叠-后者覆盖前者
#### 优先级
* !important > 行内样式(style) > ID选择器 > 类选择器 > 标签 > 通配符

### BFC的理解
* Block Formatting Context 是web页面可视化css渲染的一部分，是块盒子的布局过程发生的区域，
  也是浮动元素和其他元素交互的区域。HTML元素在这个环境中按照一定规则进行布局。
* 具有BFC特性的元素可以看做是隔离的独立容器，容器里面的元素不会在布局上影响到外面的元素。
#### 触发BFC
* body根元素
* 浮动元素 float出none以外
* 绝对定位元素 position(absolute，fixed)
* display为inline-block table-cell flex
* overflow除visible以外的值
#### 特性
* 同一个BFC下外边距会发生折叠
* 清除浮动(包含浮动的元素)
* 阻止元素被浮动元素覆盖

### Vue中的data为什么是函数不是对象
* 组件中写成函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，
  类似给每个实例组件创建一个私有的数据空间，让每个组件实例维护各自的数据。而单纯的写成
  对象形式，就使得所有组件共用一份data，会相互影响。

### 面试题链接
* https://zhuanlan.zhihu.com/p/63962882
* https://mp.weixin.qq.com/s/kB1Ncsbccd110LSW5qnxQA

### 为什么最好把css的link标签放在<head>之间？
* 是规范要求，这种做法可以让页面逐步呈现，提高用户体验，防止呈现给用户空白或没有样式的内容。
### 为什么最好把JS的<script>标签放在<body/>之前，有例外吗？
* 脚本在下载和执行期间会阻止HTML解析，把script放在底部保证HTML首先完成解析，将页面尽早
  呈现给用户。
* 例外情况是脚本里包含document.write()

### 请简述JavaScript中的this  如何确定this指向

### SPA(single-page application)的理解及优缺点
* SPA只在页面初始化时加载相应的html，js和css。一旦页面加载完成，SPA不会因为用户的操作而
  重新加载或跳转，而是利用路由机制实现HTML内容的切换、UI与用户的交互，避免页面重新加载。
* 优点
  > 用户体验好，页面流畅，内容的改变不会重新加载整个页面，避免了不必要的跳转和重新渲染
  > 相对于服务器压力较小
  > 前后端职责分离，架构清晰。
* 缺点
  > 初次加载消耗多，资源一次性统一加载
  > 前进后退路由管理，不能使用浏览器的前进后退功能，所有页面的切换需要自己建立堆栈管理
  > SEO难度较大

### Vue单向数据流的理解
* 所有的prop都使得父子prop之间形成一个单向下行绑定，父级prop的更新会向下流动到子组件中，
  反之则不行。这样可以阻止子组件改变父组件的状态，从而导致应用数据流难以理解。每次父组件
  prop值更新时，子组件所有的prop都将刷新为最新的值。子组件想要修改父组件的prop，只能通过
  $emit派发一个自定义事件，父组件可在该事件中触发prop更新。

### computed和watch的区别
* computed 计算属性，依赖其他属性值，并且值有缓存，避免了每次获取时都要重新计算，只有它依赖的属性值发生变化时，下一次获取
  computed的值才会重新计算
* watch 更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调操作

### 可以在哪些生命周期内调用异步请求
* created(), beforeMount(), mounted() 因为这三个钩子函数中的data已经创建，可以将服务器端的数据进行赋值
* 建议在created()调用
  > 能更快的获取服务端数据，减少页面loading时间
  > 服务器端渲染(SSR)不支持beforeMount(), mounted()钩子函数

### keep-alive的理解
* <keep-alive>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。自身不会渲染一个DOM元素，也不会出现在父组件链中
* 当组件在<keep-alive>内被切换时，它的activated()和deactivated()这两个生命周期函数将会被执行
* include 和 exclude 属性允许组件有条件的缓存，可用逗号分隔符，正则表达式，数组标识；匹配首先检查组件自身的name选项，
  如果name选项不可用，则匹配它的局部注册名称(父组件components选项的键值)。匿名组件不能被匹配
* max 最多可以缓存多少组件实例。一旦这个数字达到了，在新实例创建之前，已缓存组件中最久没有被访问的实例会被销毁掉

### 深入响应式原理
* 当把一个普通的JavaScript对象传入Vue实例作为data选项，Vue将遍历此对象所有的属性，并使用 Object.defineProperty()
  把这些属性全部转为 getter/setter。这些 getter/setter 对用户不可见，但是在内部他们让Vue追踪依赖，在属性被访问和
  修改时通知变更。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把接触过的数据属性记录为依赖，之后当依赖
  项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

### SSR
* 默认情况下，可以在浏览器中输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务器端的html字符串，
  将它们直接发送到浏览器，最后将这些静态标记激活为客户端完全可以交互的应用程序。
 
### 面试题
1. 
```
let a = {a: 10};
let b = {b: 10};
let obj = {
  a: 10
};
obj[b] = 20;
console.log(obj[a]); // 20
```
> 这道题目主要考对JS数据类型的熟练度以及对ES6中属性名表达式的理解。
  在上题中obj[b] = 20的赋值操作后，obj其实已经变成了{a: 10, [object Object]: 20}，
  这是因为如果属性名表达式是一个对象的话，那么默认情况下会自动将对象转为字符串[object Object]，
  最后一步获取obj[a]时，a本身也是一个对象，所以会被转换为获取obj['[object Object]']也就是上一步赋值的20。

