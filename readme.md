
## 原型链
* JavaScript只有一种结构：对象。  
  每个实例对象都有一个私有属性（__proto__）指向它的的构造函数的原型对象（prototype），  
  该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为null，  
  根据定义，null是没有原型的，并作为这个原型链中的最后一个环节。  
  几乎所有JavaScript中的对象都是位于原型链顶端的Object实例。
* JavaScript有一个指向一个原型对象的链，当试图访问对象的属性时，它不仅仅在该对象上搜寻，  
  还会搜寻该对象的原型，以及该对象的原型的原型，一次层层向上搜索，直到找到一个名字匹配的  
  属性或到达原型链的末尾。

* 继承方法
* 在JavaScript里，任何函数都可以添加到对象上作为对象的属性。  
* 当继承的函数被调用时，this指向的是当前继承的函数，而不是继承的函数所在的原型对象  

## 面向对象的三大特性： 继承 多态 封装

## 闭包的理解
* 链式作用域结构，子对象会一级一级地向上寻找所有父对象的变量。  
  所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
* 优缺点
  > 优点：可以避免全局变量的污染
  > 缺点：常驻内存，增加内存使用量，使用不当容易造成内存泄露。
* 特性
  > 函数嵌套函数
  > 在函数内部可以引用外部的参数和变量
  > 参数和变量不会以垃圾回收机制回收

## Vue 通信
* props
* $emit
* $refs
* $parent  $children
* eventBus

## Vue Loader

## Vuex
### Vuex 和单纯的全局对象有以下两点不同
* Vuex 的状态储存是响应式的。若store中的状态发生改变，那么相应的组件也会得到相应的高效更新。
* 不能直接改变store的状态。改变store中的状态唯一途径是显示的提交（commit）mutation。  
  因为想要更明确地追踪状态的变化

### 在 Vue 组件中获得 Vuex 状态
* Vuex 通过在根实例中注册 store 选项，提供一种机制将状态从根组件注入到每一个子组件中（需调用Vue.use(Vuex)）。  
  子组件能通过 this.$store 访问到。
### Mutation 必须是同步函数
* 任何在回调函数中进行的状态的改变都是不可追踪的

### Action
* Action 提交的是 mutation ，而不是直接改变状态。
* Action 可以包含任意异步操作

### Module
* 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，就有可能变得相当臃肿。  
  未解决以上问题，Vuex允许将store分割成模块（Module）。

## typeof null === 'object'
* 在js最初的实现中，js中的值是由一个表示类型的标签和实际数据值表示的，对象（object）的类型标签是0。  
  由于null代表空指针（大多数平台下的值为0x00），因此，null的类型标签是0。

## Javascript 严格模式
* 消除 JavaScript 语法的一些不合理、不严谨之处
* 消除代码运行的不安全之处，保证代码运行的安全
* 提高编译器效率，增加运行速度
* 为未来的 JavaScript 版本做好铺垫

## 为什么JavaScript是单线程
* 作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作DOM。  
  这决定了它只能是单线程，否则会带来很复杂的同步问题。
### 任务队列 同步任务和异步任务
* 同步任务，在主线程上排队执行的任务，只有前一个任务执行完毕，才执行下一个任务。
* 异步任务，不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个任务可以执行了，  
  该任务才进入主线程执行。
* 只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。
* 任务队列是一个事件的队列，IO设备完成一项任务，就在任务队列中添加一个事件，表示相关的异步任务  
  可以进入执行栈了。主线程读取任务队列，就是读取里面有哪些事件。异步任务必须指定回调函数，当主线程开始  
  执行异步任务，其实就是执行对应的回调函数。

### 定时器
* setTimeout(function() {}, time) 一次性执行  
  只是将事件插入了任务队列，必须等主线程执行完，才会去执行它指定的回调函数
* setInterval(function() {}, time) 循环执行

## IIFE 立即调用函数表达式